import process from 'node:process';
import { logLevel, isDevelopment, baseUrl, platform } from '@arcjet/env';
import { ArcjetHeaders } from '@arcjet/headers';
import findIp, { parseProxy } from '@arcjet/ip';
import { Logger } from '@arcjet/logger';
import { createClient } from '@arcjet/protocol/client.js';
import { createTransport } from '@arcjet/transport';
import arcjetCore__default from 'arcjet';
export * from 'arcjet';

// TODO(@wooorm-arcjet): deduplicate.
function errorMessage(err) {
    if (err) {
        if (typeof err === "string") {
            return err;
        }
        if (typeof err === "object" &&
            "message" in err &&
            typeof err.message === "string") {
            return err.message;
        }
    }
    return "Unknown problem";
}
/**
 * Create a remote client.
 *
 * @param options
 *   Configuration (optional).
 * @returns
 *   Client.
 */
function createRemoteClient(options) {
    const settings = options ?? {};
    const baseUrl$1 = settings.baseUrl ?? baseUrl(process.env);
    return createClient({
        baseUrl: baseUrl$1,
        sdkStack: "FASTIFY",
        sdkVersion: "1.0.0-beta.13",
        timeout: settings.timeout ?? (isDevelopment(process.env) ? 1000 : 500),
        transport: createTransport(baseUrl$1),
    });
}
/**
 * Create a new Fastify integration of Arcjet.
 *
 * > ðŸ‘‰ **Tip**:
 * > build your initial base client with as many rules as possible outside of a
 * > request handler;
 * > if you need more rules inside handlers later then you can call `withRule()`
 * > on that base client.
 *
 * @template Rules
 *   List of rules.
 * @template Characteristics
 *   Characteristics to track a user by.
 * @param options
 *   Configuration.
 * @returns
 *   Fastify integration of Arcjet.
 */
function arcjet(options) {
    const client = options.client ?? createRemoteClient();
    const log = options.log
        ? options.log
        : new Logger({ level: logLevel(process.env) });
    const proxies = options.proxies ? options.proxies.map(parseProxy) : undefined;
    if (isDevelopment(process.env)) {
        log.warn("Arcjet will use 127.0.0.1 when missing public IP address in development mode");
    }
    function withClient(aj) {
        return Object.freeze({
            async protect(fastifyRequest, ...[properties]) {
                const arcjetRequest = toArcjetRequest(fastifyRequest, log, proxies, properties || {});
                return aj.protect({ getBody }, 
                // @ts-expect-error: TODO(#220): fix types for arcjet requests.
                arcjetRequest);
                async function getBody() {
                    try {
                        if (typeof fastifyRequest.body === "string") {
                            return fastifyRequest.body;
                        }
                        else if (fastifyRequest.body === null ||
                            fastifyRequest.body === undefined) {
                            return undefined;
                        }
                        else {
                            return JSON.stringify(fastifyRequest.body);
                        }
                    }
                    catch (e) {
                        log.error("failed to get request body: %s", errorMessage(e));
                        return;
                    }
                }
            },
            withRule(rule) {
                const childClient = aj.withRule(rule);
                return withClient(childClient);
            },
        });
    }
    const childClient = arcjetCore__default({ ...options, client, log });
    return withClient(childClient);
}
/**
 * Create an Arcjet request.
 *
 * @param request
 *   Fastify request.
 * @param log
 *   Logger.
 * @param proxies
 *   Proxies.
 * @param properties
 *   Properties.
 * @returns
 *   Arcjet request.
 */
function toArcjetRequest(request, log, 
// TODO(@wooorm-arcjet): use `Cidr` type here.
proxies, properties) {
    const requestHeaders = request.headers || {};
    // Extract cookies from original headers.
    // `ArcjetHeaders` removes the cookie header because it often contains
    // sensitive information.
    // We send cookies to the server as a separate field on the protobuf and
    // handle them differently than other headers due to that potential.
    const cookies = typeof requestHeaders.cookie === "string" ? requestHeaders.cookie : "";
    const headers = new ArcjetHeaders(requestHeaders);
    let ip = findIp({ headers, socket: request.socket }, { platform: platform(process.env), proxies });
    if (ip === "") {
        if (isDevelopment(process.env)) {
            ip = "127.0.0.1";
        }
        else {
            log.warn(`Client IP address is missing. If this is a dev environment set the ARCJET_ENV env var to "development"`);
        }
    }
    const method = request.method ?? "";
    const host = headers.get("host") ?? "";
    let path = "";
    let protocol = request.protocol === "https" || request.protocol === "http"
        ? request.protocol + ":"
        : request.server.initialConfig?.https
            ? "https:"
            : "http:";
    let query = "";
    // Do some very simple validation, but also try/catch around URL parsing
    if (request.url && host !== "") {
        try {
            const url = new URL(request.url, `${protocol}//${host}`);
            path = url.pathname;
            query = url.search;
            protocol = url.protocol;
        }
        catch {
            // If the parsing above fails, just set the path as whatever url we
            // received.
            path = request.url ?? "";
            log.warn('Unable to parse URL. Using "%s" as `path`.', path);
        }
    }
    else {
        path = request.url ?? "";
    }
    return {
        ...properties,
        cookies,
        headers,
        host,
        ip,
        method,
        path,
        protocol,
        query,
    };
}

export { createRemoteClient, arcjet as default };
